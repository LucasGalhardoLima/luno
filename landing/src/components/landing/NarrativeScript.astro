---
import type { SiteConfig } from '@/config/site';
import type { LandingCopy } from '@/content/types';

interface Props {
  locales: Record<'pt-BR' | 'en-US', LandingCopy>;
  config: SiteConfig;
}

const { locales, config } = Astro.props;
---

<script is:inline id="copy-data" type="application/json" set:html={JSON.stringify(locales)}></script>
<script is:inline id="site-config" type="application/json" set:html={JSON.stringify(config)}></script>
<script>
  type Locale = 'pt-BR' | 'en-US';
  type LandingEventName =
    | 'landing_view'
    | 'hero_cta_click'
    | 'waitlist_submit_start'
    | 'waitlist_submit_success'
    | 'waitlist_submit_error'
    | 'story_scene_view'
    | 'theme_toggle';
  type ThemeName = 'dark' | 'light';
  type AnalyticsPayload = Record<string, string | number | boolean | null>;
  type UtmKey =
    | 'utm_source'
    | 'utm_medium'
    | 'utm_campaign'
    | 'utm_term'
    | 'utm_content'
    | 'gclid'
    | 'fbclid';
  type UtmMap = Partial<Record<UtmKey, string>>;

  interface SiteConfigClient {
    defaultLocale: Locale;
    waitlistProvider: 'formspree' | 'custom';
    analyticsEnabled: boolean;
  }

  interface CopyClient {
    seo: {
      title: string;
      description: string;
    };
    waitlist: {
      submit: string;
      pending: string;
      success: string;
      error: string;
    };
    themeToggle: {
      dark: string;
      light: string;
    };
    [key: string]: unknown;
  }

  function parseJsonScript<T>(id: string): T {
    const node = document.getElementById(id);
    if (!(node instanceof HTMLScriptElement) || !node.textContent) {
      throw new Error(`Missing JSON script: ${id}`);
    }
    return JSON.parse(node.textContent) as T;
  }

  function inferLocale(language: string | undefined, fallback: Locale): Locale {
    if (!language) return fallback;
    const normalized = language.toLowerCase();
    if (normalized.startsWith('pt')) return 'pt-BR';
    if (normalized.startsWith('en')) return 'en-US';
    return fallback;
  }

  function readUtmParams(search: URLSearchParams): UtmMap {
    const keys: UtmKey[] = [
      'utm_source',
      'utm_medium',
      'utm_campaign',
      'utm_term',
      'utm_content',
      'gclid',
      'fbclid',
    ];

    return keys.reduce<UtmMap>((acc, key) => {
      const value = search.get(key);
      if (value) acc[key] = value;
      return acc;
    }, {});
  }

  function appendUtmToUrl(href: string, utm: UtmMap): string {
    try {
      const url = new URL(href, window.location.origin);
      Object.entries(utm).forEach(([key, value]) => {
        if (value && !url.searchParams.has(key)) {
          url.searchParams.set(key, value);
        }
      });
      if (href.startsWith('http')) return url.toString();
      return `${url.pathname}${url.search}${url.hash}`;
    } catch {
      return href;
    }
  }

  function trackEvent(
    config: SiteConfigClient,
    eventName: LandingEventName,
    payload: AnalyticsPayload = {}
  ): void {
    if (!config.analyticsEnabled) return;

    const state = window as Window & {
      dataLayer?: Array<Record<string, unknown>>;
    };
    state.dataLayer = state.dataLayer || [];

    const event = {
      event: eventName,
      timestamp: Date.now(),
      ...payload,
    };

    state.dataLayer.push(event);
    window.dispatchEvent(new CustomEvent('luno:analytics', { detail: event }));
  }

  function getValueByPath(object: unknown, path: string): string | undefined {
    const result = path.split('.').reduce<unknown>((acc, part) => {
      if (acc === null || acc === undefined) return undefined;
      if (Array.isArray(acc) && !Number.isNaN(Number(part))) {
        return acc[Number(part)];
      }
      if (typeof acc === 'object') {
        return (acc as Record<string, unknown>)[part];
      }
      return undefined;
    }, object);

    return typeof result === 'string' ? result : undefined;
  }

  function normalizeTheme(theme: string | null | undefined): ThemeName {
    return theme === 'light' ? 'light' : 'dark';
  }

  function normalizeSceneId(scene: string | undefined): string | null {
    const validScenes = ['hook', 'reveal', 'para-map', 'proof-flow', 'finale'];
    if (!scene) return null;
    return validScenes.includes(scene) ? scene : null;
  }

  function getSystemTheme(): ThemeName {
    return window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark';
  }

  const copyData = parseJsonScript<Record<Locale, CopyClient>>('copy-data');
  const config = parseJsonScript<SiteConfigClient>('site-config');

  const formEl = document.getElementById('waitlist-form');
  const submitButtonEl = document.getElementById('waitlist-submit');
  const feedbackEl = document.getElementById('form-feedback');
  const localeInputEl = document.getElementById('locale');

  if (
    !(formEl instanceof HTMLFormElement) ||
    !(submitButtonEl instanceof HTMLButtonElement) ||
    !(feedbackEl instanceof HTMLElement) ||
    !(localeInputEl instanceof HTMLInputElement)
  ) {
    throw new Error('Waitlist form elements are missing');
  }

  const form: HTMLFormElement = formEl;
  const submitButton: HTMLButtonElement = submitButtonEl;
  const feedback: HTMLElement = feedbackEl;
  const localeInput: HTMLInputElement = localeInputEl;

  const locale = inferLocale(navigator.language, config.defaultLocale);
  const copy = copyData[locale] || copyData[config.defaultLocale];
  const themeToggleButton = document.getElementById('theme-toggle');
  const themeToggleLabel = document.getElementById('theme-toggle-label');

  document.documentElement.classList.add('js-ready');
  document.documentElement.lang = locale;
  localeInput.value = locale;

  function updateThemeUi(theme: ThemeName): void {
    if (
      !(themeToggleButton instanceof HTMLButtonElement) ||
      !(themeToggleLabel instanceof HTMLElement)
    ) {
      return;
    }
    const label = theme === 'dark' ? copy.themeToggle.dark : copy.themeToggle.light;
    themeToggleLabel.textContent = label;
    themeToggleButton.setAttribute('aria-label', label);
    themeToggleButton.setAttribute('title', label);
    themeToggleButton.dataset.theme = theme;
  }

  function applyTheme(theme: ThemeName, persist: boolean): void {
    document.documentElement.dataset.theme = theme;
    updateThemeUi(theme);
    if (!persist) return;
    try {
      window.localStorage.setItem('luno-theme', theme);
    } catch {
      // noop: localStorage may be blocked
    }
  }

  const initialTheme = normalizeTheme(document.documentElement.dataset.theme || getSystemTheme());
  applyTheme(initialTheme, false);

  if (themeToggleButton instanceof HTMLButtonElement) {
    themeToggleButton.addEventListener('click', () => {
      const from = normalizeTheme(document.documentElement.dataset.theme);
      const to: ThemeName = from === 'dark' ? 'light' : 'dark';
      applyTheme(to, true);
      trackEvent(config, 'theme_toggle', { locale, from, to });
    });
  }

  document.querySelectorAll<HTMLElement>('[data-i18n]').forEach((node) => {
    const key = node.dataset.i18n;
    if (!key) return;
    const value = getValueByPath(copy, key);
    if (value) node.textContent = value;
  });

  document
    .querySelectorAll<HTMLInputElement | HTMLTextAreaElement>('[data-i18n-placeholder]')
    .forEach((node) => {
      const key = node.dataset.i18nPlaceholder;
      if (!key) return;
      const value = getValueByPath(copy, key);
      if (value) node.setAttribute('placeholder', value);
    });

  document.title = copy.seo.title;
  const description = copy.seo.description;
  document.getElementById('meta-description')?.setAttribute('content', description);
  document.getElementById('meta-og-title')?.setAttribute('content', copy.seo.title);
  document.getElementById('meta-og-description')?.setAttribute('content', description);
  document.getElementById('meta-twitter-title')?.setAttribute('content', copy.seo.title);
  document.getElementById('meta-twitter-description')?.setAttribute('content', description);

  const search = new URLSearchParams(window.location.search);
  const utm = readUtmParams(search);

  Object.entries(utm).forEach(([key, value]) => {
    const input = document.getElementById(key);
    if (input instanceof HTMLInputElement) {
      input.value = value;
    }
  });

  document.querySelectorAll<HTMLAnchorElement>('[data-preserve-utm]').forEach((link) => {
    const href = link.getAttribute('href');
    if (!href) return;
    link.setAttribute('href', appendUtmToUrl(href, utm));
  });

  document.querySelectorAll<HTMLAnchorElement>('[data-track-cta]').forEach((button) => {
    button.addEventListener('click', () => {
      trackEvent(config, 'hero_cta_click', {
        locale,
        target: button.getAttribute('href') || '#waitlist',
      });
    });
  });

  form.addEventListener('submit', async (event: SubmitEvent) => {
    event.preventDefault();

    const emailInput = form.querySelector('#email');
    const honeypot = form.querySelector('#website');
    if (!(emailInput instanceof HTMLInputElement)) return;
    if (honeypot instanceof HTMLInputElement && honeypot.value) return;

    if (!emailInput.checkValidity()) {
      feedback.textContent = copy.waitlist.error;
      trackEvent(config, 'waitlist_submit_error', { locale, reason: 'invalid_email' });
      return;
    }

    submitButton.disabled = true;
    submitButton.textContent = copy.waitlist.pending;
    feedback.textContent = '';

    trackEvent(config, 'waitlist_submit_start', {
      locale,
      provider: config.waitlistProvider,
    });

    try {
      const payload = new FormData(form);
      await fetch(form.action, {
        method: 'POST',
        body: payload,
        mode: 'no-cors',
      });

      form.reset();
      localeInput.value = locale;
      Object.entries(utm).forEach(([key, value]) => {
        const input = document.getElementById(key);
        if (input instanceof HTMLInputElement) {
          input.value = value;
        }
      });

      feedback.textContent = copy.waitlist.success;
      trackEvent(config, 'waitlist_submit_success', {
        locale,
        provider: config.waitlistProvider,
      });
    } catch {
      feedback.textContent = copy.waitlist.error;
      trackEvent(config, 'waitlist_submit_error', { locale, reason: 'network' });
    } finally {
      submitButton.disabled = false;
      submitButton.textContent = copy.waitlist.submit;
    }
  });

  const phaseItems = Array.from(document.querySelectorAll<HTMLElement>('[data-phase-item]'));
  const phaseProgress = document.getElementById('phase-progress');
  const scenes = Array.from(document.querySelectorAll<HTMLElement>('[data-scene]'));

  function setActivePhase(index: number): void {
    phaseItems.forEach((item, itemIndex) => {
      item.dataset.active = itemIndex <= index ? '1' : '0';
    });

    if (phaseProgress) {
      const max = Math.max(phaseItems.length - 1, 1);
      const ratio = Math.min(Math.max(index / max, 0), 1);
      phaseProgress.style.setProperty('--phase-progress', ratio.toString());
    }
  }

  const sceneObserver = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (!entry.isIntersecting || !(entry.target instanceof HTMLElement)) return;

        const scene = normalizeSceneId(entry.target.dataset.scene);
        const sceneIndex = scenes.indexOf(entry.target);
        if (sceneIndex >= 0) {
          setActivePhase(sceneIndex);
        }

        if (!scene || entry.target.dataset.tracked === '1') return;
        entry.target.dataset.tracked = '1';
        trackEvent(config, 'story_scene_view', { locale, scene });
      });
    },
    { threshold: 0.45 }
  );

  scenes.forEach((scene) => {
    sceneObserver.observe(scene);
  });

  const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  const mobileLite = window.matchMedia('(max-width: 900px)').matches;
  const allowHeavyMotion = !reducedMotion && !mobileLite;

  const revealObserver = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (!(entry.target instanceof HTMLElement)) return;
        if (entry.isIntersecting) {
          entry.target.classList.add('is-visible');
          revealObserver.unobserve(entry.target);
        }
      });
    },
    { threshold: 0.14 }
  );

  document.querySelectorAll<HTMLElement>('.reveal').forEach((node) => {
    revealObserver.observe(node);
  });

  if (allowHeavyMotion) {
    const parallaxNodes = Array.from(document.querySelectorAll<HTMLElement>('[data-parallax]'));
    const mapNodes = Array.from(document.querySelectorAll<HTMLElement>('[data-map-node]'));

    window.addEventListener('pointermove', (event: PointerEvent) => {
      const centerX = window.innerWidth / 2;
      const centerY = window.innerHeight / 2;
      const offsetX = (event.clientX - centerX) / centerX;
      const offsetY = (event.clientY - centerY) / centerY;

      parallaxNodes.forEach((node) => {
        const strength = Number(node.dataset.parallax || 0.01);
        const moveX = offsetX * 24 * strength * 100;
        const moveY = offsetY * 20 * strength * 100;
        node.style.transform = `translate3d(${moveX}px, ${moveY}px, 0)`;
      });
    });

    document.querySelectorAll<HTMLElement>('[data-tilt]').forEach((node) => {
      node.addEventListener('pointermove', (event: PointerEvent) => {
        const rect = node.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const rotateX = ((event.clientY - centerY) / rect.height) * -4.8;
        const rotateY = ((event.clientX - centerX) / rect.width) * 5.8;
        node.style.transform = `perspective(1200px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
      });

      node.addEventListener('pointerleave', () => {
        node.style.transform = 'perspective(1200px) rotateX(0deg) rotateY(0deg)';
      });
    });

    mapNodes.forEach((node) => {
      node.addEventListener('pointerenter', () => {
        node.dataset.active = '1';
      });
      node.addEventListener('pointerleave', () => {
        node.dataset.active = '0';
      });
      node.addEventListener('focusin', () => {
        node.dataset.active = '1';
      });
      node.addEventListener('focusout', () => {
        node.dataset.active = '0';
      });
    });
  }

  const currentYear = document.getElementById('current-year');
  if (currentYear) {
    currentYear.textContent = String(new Date().getFullYear());
  }

  setActivePhase(0);

  trackEvent(config, 'landing_view', {
    locale,
    theme: normalizeTheme(document.documentElement.dataset.theme),
    source: utm.utm_source || 'direct',
  });
</script>
